
% g est une valeur qui s incremente : g2 = g1 + cout de g1 à g2.
% Fonction g qui clacul le chemin entre X1,Y1 et X2,Y2 avec X2,Y2 = le point précédent + distance entre les deux points.

g([], [], 0, 0).
g([X1,Y1], [X1,Y1], A, A).
g([X1,Y1], [X2,Y2], 0, Z):- distance([X1,Y1], [X2,Y2],Z).
g([X1,Y1], [X2,Y2], A, Z):- distance([X1,Y1], [X2,Y2],B), Z is A+B.

% distance calcul la distance euclidienne entre deux points (en coordonnées x,y).

distance([],[],0).
distance([A,B],[], C):- C is sqrt((A * A) + (B * B)).
distance([],[A,B],C):- C is sqrt((A * A) + (B * B)).
distance([A,B],[A,B],0).
distance([A1,B1],[A2,B2],C):- C is sqrt(((A2 - A1) * (A2 - A1)) + ((B2 - B1) * (B2 - B1))).

% Fonction f qui calcul le cout courant du chemin + la distance euclidienne restante
% couple1 : point précédant à N-1, couple2 : point courant exploré N, couple3 : point final, A : distance parcouru lors de la solution N-1, R : cout total

f([],[],[],0,0).
f([X1,Y1], [X1,Y1], [X2,Y2], A, A).
f([X1,Y1], [X2,Y2], [X3,Y3], A, R):- g([X1,Y1],[X2,Y2],A, B), distance([X2,Y2], [X3,Y3], C), R is B+C.

% Permet de parourir la liste et d'afficher les coordoonnées X,Y

parcour_liste([X,Y|R], [X,Y]).
parcour_liste([X1,Y1|R], [X2,Y2]):- parcour_liste(R, [X2,Y2]).

% On test la position du robot. True : Il est sur l'objectif; False : il ne l'est pas

robot_sur_objectif([X1,Y1], [X2,Y2]):- X1 =:= X2, Y1 =:= Y2.

% Permet d'afficher le contenue de ClosedList

affiche_solution(ClosedList, A):- parcour_liste(ClosedList, A).

% On regarde si le robot est sur l'objectif. True : On affidche le contenue de ClosedList; False : On continue de chercher le meilleur noeud fils

si_robot_sur_objectif([X1,Y1], [X3,Y3], OpenList, ClosedList, Cout, A):- robot_sur_objectif([X1,Y1],[X3,Y3]), !, affiche_solution(Closed, A).
si_robot_sur_objectif([X1,Y1], [X3,Y3], OpenList, ClosedList, Cout, A):- meilleur_successeur([X1,Y1], [X2,Y2], [X3,Y3], Cout, Closed, OpenList, Resultat).

% Prédicat qui cherche le meilleur neoud fils à visiter.
% A Compléter !!!

meilleur_successeur([X1,Y1], [X2,Y2], [X3,Y3], Cout, ClosedList, OpenList, Resultat):- not(parcourir_liste(Closed, [X2,Y2])), not(parcourir_liste(OpenList, [X2,Y2])), f([X1,Y1], [X2,Y2], [X3,Y3], Cout, Resultat).
meilleur_successeur([X1,Y1], [X2,Y2], [X3,Y3], Cout, ClosedList, OpenList, Resultat):- g([X1,Y1], [X2,Y2], Cout, A), distance([X1,Y1],[X2,Y2],B), A > Cout + B, f([X1,Y1], [X2,Y2], [X3,Y3], Cout, Resultat).

% Pour insérer les coordonnées dans ClosedList : Utiliser append([X,Y], ClosedList, Resultat).

% Recupere les coordonnées du robot lorsqu'il se déplace

init(_):- nb_setval(OpenList, []), nb_setval(ClosedList, []), nb_setval(Path1, []) .

a_star([PositionBalise, 0, 0, -1], [PositionBalise,_, 0,_], []).
a_star(State1, State2, Path):-nb_getval(OpenList, []),!, nb_setval(OpenList, [State1]), a_star(State2, Path).

a_star(_,_):- nb_getval(OpenList, []), !, fail.
a_star([PosotionBalise, _, 0, _], Path):- getBestNodeFromOpenList([PositionBalise,_,0,_]), !, buildPath(Path).
a_star(State2, Path):- 
	extractBestNodeFromOpenList(Noeud),
	completerClosed(Noeud), 
	getAllAccessibleStates(Noeud, StatesList), 
	insertAllStatesInOpenList(Noeud, State2, SatesList),
	a_star(State2, Path).

	
%  openlist(noeud).
%  noeud(numero_noeud, noeud_parent, pos_courante, cout).

 
% Retourne (sans supprimer) le noeud de open avec le plus petit cout f

getBestNodeFromOpenList(Noeud):- nb_getval(OpenList, [Noeud|_]).

completerClosed(Noeud):- nb_getval(ClosedList, ValeurClosed), append([Noeud], ValeurClosed, ClosedList2),nb_setval(ClosedList, ClosedList2).

% Meme chose mais le supprime de open

extractBestNodeFromOpenList(noeud):- nb_getval(OpenList,[noeud|R]), nb_setval(OpenList, R).

% Retourne le chemin à suivre dans la forme donnée par le sujet
% Le noeud fin
buildPath(State, Path).

% insert tous les noeuds de AccessibleStateList dans open

insertAllStateInOpenList(noeud, FinalState, AccessibleStateList).

% Donne la valeur de l'heuristique, ici Manhattan

getHeuristicValue(State, FinalState, V).

% Retourne tous les états accessibles depuis l'état actuel "State" (je pense qu on doit traiter ceux dans open et closed mais je ne sais pas comment)

getAllAccessibleStates([X,Y,_,_,_], AccessibleStatesList):-
	deplacement([X,Y,1,_,_,_,_,TL,TR,BL,BR,_]),
	deplacement([X,Y,2,_,_,_,_,TL,TR,BL,BR,_]),
	deplacement([X,Y,3,_,_,_,_,TL,TR,BL,BR,_]),
	deplacement([X,Y,4,_,_,_,_,TL,TR,BL,BR,_]),
	checkRes([ResH,ResB,ResL,ResR],AccessibleStatesList).
			
checkRes(LRes,AccessibleStatesList):-
		nb_getval(openList,Open),
		nb_getval(closedList,Closed),
		checkRes(LRes,Open,Closed,AccessibleStatesList).
			
checkRes([],_,_,[]):-!.
checkRes([A|R],[],[],Res):-append([A],Res1,Res),
			nb_getval(openList,Open),nb_getval(closedList,Closed),
			checkRes(R,Open,Closed,Res1),!.
checkRes([A|R],[],[[A,_,_,_]|_],Res):-
			nb_getval(closedList,Closed),
			nb_getval(openList,Open),
			checkRes(R,Open,Closed,Res),!.
checkRes([A|R],[],[_|RC],Res):-
			checkRes([A|R],[],RC,Res),!.
checkRes([A|R],[[A,_,_,_]|_],Closed,Res):-
			nb_getval(openList,Open),
			checkRes(R,Open,Closed,Res).
checkRes([A|R],[_|RO],Closed,Res):-
			checkRes([A|R],RO,Closed,Res).
			
insertAllStatesInOpenList(_,_,[]).
insertAllStatesInOpenList([PositionPere,N,_,_],[PositionBalise,_,0,_],[PositionRobot|R]):-
		distance(PositionRobot,PositionBalise,D), 
		N1 is N+1, 
		nb_getval(OpenList,OpenList2), 		
		insertTri([PosisionRobot,N1,D,PositionPere],OpenList2,OpenList3),
		nb_setval(OpenList,OpenList3),
		insertAllStatesInOpenList([PositionPere,N,_,_],[PositionBalise,_,0,_],R).


move( [TL, TR, BL, BR, _, BX, BY | _],[]) :- deplacement(BX, BY, 1, NX, NY, TL, TR, BL, BR, N).

deplacement(X,Y,1,X,Y,N, TL, TR, BL, BR, N) :- obstacle(X,Y, TL, TR, BL, BR,0), writef('deplacement : %t\n',[N]),!.
deplacement(X,Y,3,X,Y,N, TL, TR, BL, BR, N) :- obstacle(X,Y, TL, TR, BL, BR,0), writef('deplacement : %t\n',[N]),!.
deplacement(X,Y,2,X,Y,N, TL, TR, BL, BR, N) :- obstacle(X,Y, TL, TR, BL, BR,1), writef('deplacement : %t\n',[N]),!.
deplacement(X,Y,4,X,Y,N, TL, TR, BL, BR, N) :- obstacle(X,Y, TL, TR, BL, BR,1), writef('deplacement : %t\n',[N]),!.

deplacement(X,Y,1,NX,NY,N, TL, TR, BL, BR,NBR) :- N1 is N+1, X1 is X+1, deplacement(X1,Y,1, NX,NY, N1, TL, TR, BL, BR,NBR).
deplacement(X,Y,3,NX,NY,N, TL, TR, BL, BR,NBR) :- N1 is N+1, X1 is X-1, deplacement(X1,Y,3, NX,NY, N1, TL, TR, BL, BR,NBR).
deplacement(X,Y,2,NX,NY,N, TL, TR, BL, BR,NBR) :- N1 is N+1, Y1 is Y+1, deplacement(X,Y1,2, NX,NY, N1, TL, TR, BL, BR,NBR).
deplacement(X,Y,4,NX,NY,N, TL, TR, BL, BR,NBR) :- N1 is N+1, Y1 is Y-1, deplacement(X,Y1,4, NX,NY, N1, TL, TR, BL, BR,NBR).

deplacement(X,Y, D, NX, NY, TL, TR, BL, BR,NBR) :- deplacement(X,Y, D,NX, NY,0, TL, TR, BL, BR,NBR).

% On lance au démarrage du tour, on détermine les choix possibles

lancement([X1,Y1], [X3,Y3], ClosedList, OpenList, Robot, Cout, TL, TR, BL, BR):- deplacement(X1, Y1, _, BX, BY, _, TL, TR, BL, BR, 0), f([X1,Y1], [BX,BY], [X3,Y3], 0, Cout), append(ClosedList, [X1,Y1], Closed2), append(OpenList, [X2,Y2], Open2), astar([X1,Y1], [X2,Y2], [X3,Y3], Open2, Closed2, Cout, Robot).
