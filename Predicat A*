
% g est une valeur qui s incremente : g2 = g1 + cout de g1 à g2.
% Fonction g qui clacul le chemin entre X1,Y1 et X2,Y2 avec X2,Y2 = le point précédent + distance entre les deux points.

g([], [], 0, 0).
g([X1,Y1], [X1,Y1], A, A).
g([X1,Y1], [X2,Y2], 0, Z):- distance([X1,Y1], [X2,Y2],Z).
g([X1,Y1], [X2,Y2], A, Z):- distance([X1,Y1], [X2,Y2],B), Z is A+B.

% distance calcul la distance euclidienne entre deux points (en coordonnées x,y).

distance([],[],0).
distance([A,B],[], C):- C is sqrt((A * A) + (B * B)).
distance([],[A,B],C):- C is sqrt((A * A) + (B * B)).
distance([A,B],[A,B],0).
distance([A1,B1],[A2,B2],C):- C is sqrt(((A2 - A1) * (A2 - A1)) + ((B2 - B1) * (B2 - B1))).

% Fonction f qui calcul le cout courant du chemin + la distance euclidienne restante
% couple1 : point précédant à N-1, couple2 : point courant exploré N, couple3 : point final, A : distance parcouru lors de la solution N-1, R : cout total

f([],[],[],0,0).
f([X1,Y1], [X1,Y1], [X2,Y2], A, A).
f([X1,Y1], [X2,Y2], [X3,Y3], A, R):- g([X1,Y1],[X2,Y2],A, B), distance([X2,Y2], [X3,Y3], C), R is B+C.

% Permet de parourir la liste et d'afficher les coordoonnées X,Y

parcour_liste([X,Y|R], [X,Y]).
parcour_liste([X1,Y1|R], [X2,Y2]):- parcour_liste(R, [X2,Y2]).

% On test la position du robot. True : Il est sur l'objectif; False : il ne l'est pas

robot_sur_objectif([X1,Y1], [X2,Y2]):- X1 =:= X2, Y1 =:= Y2.

% Permet d'afficher le contenue de ClosedList

affiche_solution(ClosedList, A):- parcour_liste(ClosedList, A).

% On regarde si le robot est sur l'objectif. True : On affidche le contenue de ClosedList; False : On continue de chercher le meilleur noeud fils

si_robot_sur_objectif([X1,Y1], [X3,Y3], OpenList, ClosedList, Cout, A):- robot_sur_objectif([X1,Y1],[X3,Y3]), !, affiche_solution(Closed, A).
si_robot_sur_objectif([X1,Y1], [X3,Y3], OpenList, ClosedList, Cout, A):- meilleur_successeur([X1,Y1], [X2,Y2], [X3,Y3], Cout, Closed, OpenList, Resultat).

% Prédicat qui cherche le meilleur neoud fils à visiter.
% A Compléter !!!

meilleur_successeur([X1,Y1], [X2,Y2], [X3,Y3], Cout, ClosedList, OpenList, Resultat):- not(parcourir_liste(Closed, [X2,Y2])), not(parcourir_liste(OpenList, [X2,Y2])), f([X1,Y1], [X2,Y2], [X3,Y3], Cout, Resultat).
meilleur_successeur([X1,Y1], [X2,Y2], [X3,Y3], Cout, ClosedList, OpenList, Resultat):- g([X1,Y1], [X2,Y2], Cout, A), distance([X1,Y1],[X2,Y2],B), A > Cout + B, f([X1,Y1], [X2,Y2], [X3,Y3], Cout, Resultat).

% Pour insérer les coordonnées dans ClosedList : Utiliser append([X,Y], ClosedList, Resultat).

% Recupere les coordonnées du robot lorsqu'il se déplace

init(OpelList, [], ClosedList, []):- setval(OpenList, []), setval(ClosedList, []).

a_star( InitialState, FinalState, Path):- setval(OpenList, InitialState), a_star(FinalState, Path).
a_star(FinalState, Path).


 delete(A, [A|B], B).
 delete(A, [B, C|D], [B|E]) :- delete(A, [C|D], E).


%  openlist(noeud).
%  noeud(numero_noeud, noeud_parent, pos_courante, cout).

 
% Retourne (sans supprimer) le noeud de open avec le plus petit cout f

getBestNodeFromOpenList(openlist):- nth0(0, open_list, noeud).

% Meme chose mais le supprime de open

extractBestNodeFromOpenList(noeud):- nb_getval(OpenList,(noeud[R])), delete(noeud, OpenList, OpenList).

% Retourne le chemin à suivre dans la forme donnée par le sujet
% Le noeud fin
buildPath(State, Path).

% insert tous les noeuds de AccessibleStateList dans open

insertAllStateInOpenList(noeud, FinalState, AccessibleStateList).

% Donne la valeur de l'heuristique, ici Manhattan

getHeuristicValue(State, FinalState, V).

% Retourne tous les états accessibles depuis l'état actuel "State" (je pense qu on doit traiter ceux dans open et closed mais je ne sais pas comment)

getAllAccessibleStates(State, AccessibleStatesList).

move( [TL, TR, BL, BR, _, BX, BY | _],[]) :- deplacement(BX, BY, 1, NX, NY, TL, TR, BL, BR, N).

deplacement(X,Y,1,X,Y,N, TL, TR, BL, BR, N) :- obstacle(X,Y, TL, TR, BL, BR,0), writef('deplacement : %t\n',[N]),!.
deplacement(X,Y,3,X,Y,N, TL, TR, BL, BR, N) :- obstacle(X,Y, TL, TR, BL, BR,0), writef('deplacement : %t\n',[N]),!.
deplacement(X,Y,2,X,Y,N, TL, TR, BL, BR, N) :- obstacle(X,Y, TL, TR, BL, BR,1), writef('deplacement : %t\n',[N]),!.
deplacement(X,Y,4,X,Y,N, TL, TR, BL, BR, N) :- obstacle(X,Y, TL, TR, BL, BR,1), writef('deplacement : %t\n',[N]),!.

deplacement(X,Y,1,NX,NY,N, TL, TR, BL, BR,NBR) :- N1 is N+1, X1 is X+1, deplacement(X1,Y,1, NX,NY, N1, TL, TR, BL, BR,NBR).
deplacement(X,Y,3,NX,NY,N, TL, TR, BL, BR,NBR) :- N1 is N+1, X1 is X-1, deplacement(X1,Y,3, NX,NY, N1, TL, TR, BL, BR,NBR).
deplacement(X,Y,2,NX,NY,N, TL, TR, BL, BR,NBR) :- N1 is N+1, Y1 is Y+1, deplacement(X,Y1,2, NX,NY, N1, TL, TR, BL, BR,NBR).
deplacement(X,Y,4,NX,NY,N, TL, TR, BL, BR,NBR) :- N1 is N+1, Y1 is Y-1, deplacement(X,Y1,4, NX,NY, N1, TL, TR, BL, BR,NBR).

deplacement(X,Y, D, NX, NY, TL, TR, BL, BR,NBR) :- deplacement(X,Y, D,NX, NY,0, TL, TR, BL, BR,NBR).

% On lance au démarrage du tour, on détermine les choix possibles

lancement([X1,Y1], [X3,Y3], ClosedList, OpenList, Robot, Cout, TL, TR, BL, BR):- deplacement(X1, Y1, _, BX, BY, _, TL, TR, BL, BR, 0), f([X1,Y1], [BX,BY], [X3,Y3], 0, Cout), append(ClosedList, [X1,Y1], Closed2), append(OpenList, [X2,Y2], Open2), astar([X1,Y1], [X2,Y2], [X3,Y3], Open2, Closed2, Cout, Robot).
